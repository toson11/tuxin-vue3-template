# 数据库性能优化

### 1-查询优化

- **避免 `SELECT *`**：只选择需要的字段，减少传输的数量，降低内存和带宽消耗。
- **`WHERE` 子句添加过滤条件**：减少MySQL 必须扫描的行数。
- **使用 `LIMIT`限制结果集大小**
- **避免使用`OR`**：OR可能导致扫描更多行（`WHERE name = 'Alice' OR name = 'Bob'`），尝试用 IN 或拆分多个查询（`WHERE name IN ('Alice', 'Bob')`）
- **合理使用 JOIN 和子查询**：优化 JOIN 操作，确保 JOIN 的字段有索引。避免在子查询中过多嵌套，尝试使用 JOIN 替代子查询。

  ```mysql
  	-- 优化前========>
  	SELECT * FROM users
  	WHERE id IN (
  	SELECT user_id FROM orders WHERE status = 'completed');

  	-- 优化后========>
  	SELECT u.name, o.amount
  	-- users表（别名u）
  	FROM users u
  	-- 连接orders表（别名o），连接条件为users中的id等于orders中的user_id
  	-- 即只返回那些在 orders 表中有对应订单的用户。
  	JOIN orders o ON u.id = o.user_id
  	-- 筛选orders中状态为completed的订单
  	WHERE o.status = 'completed';
  ```

### 2-索引优化

对于查询频繁，且数据量大的表，可以创建索引，提高查询效率。
⚠️ 注意，索引会降低插入、更新、删除的效率。

```sql
-- 创建索引
CREATE INDEX index_name ON table_name (column_name);

-- 联合索引
CREATE INDEX idx_user_id_status ON orders(user_id, status);
```

### 3-表格结构设计优化

- **适当分库分表**

### 4-数据库配置优化

- `innodb_buffer_pool_size`：调整MySQL在内存中可以缓存的数据量。
- `query_cache_size`：调整缓存查询结果的大小，减少重复查询的开销，但过大的查询缓存可能导致性能下降。
- `thread_cache_size`：提升线程复用率，减少线程创建和销毁的开销。

### 5-硬件优化

- 使用SSD存储
- 增加内存
- 调整磁盘RAID

### 6-缓存优化

- 使用 Redis 或 Memcached 缓存层，减少对数据库的访问频率，减轻数据库压力。

### 7-性能分析

- 开启MySQL慢查询日志：记录执行时间久的查询。

## 选择合适的数据类型

选择合适的数据类型，可以提高查询效率。
如使用TINYINT而不是INT来存储年龄，可以节省存储空间。
UNSIGNED：无符号整数，表示非负数。

```sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    age TINYINT NOT NULL
);

ALTER TABLE users ADD COLUMN age TINYINT NOT NULL UNSIGNED;
```

# 数据一致性

### 1-外键约束

##### 级联删除

例子：假设有"用户"和"订单"两个表，当删除一个用户时，所有相关的订单也会被删除。FOREIGN 外键/外部的，CASCADE 级联的

```sql
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

##### 级联更新

例子：假设有"用户"和"订单"两个表，当更新一个用户的ID时，所有相关的订单也会被更新。

```sql
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON UPDATE CASCADE
);
```

### 2-使用事务

例子：假设有"用户"和"订单"两个表，需要确保在删除用户之前，所有相关的订单已经被删除。

```sql
START TRANSACTION;
DELETE FROM orders WHERE user_id = 1;
DELETE FROM users WHERE id = 1;
COMMIT;
```

# 分库分表

### 1-表分区

表分区是一种将大表拆分为多个小表的技术，可以提高查询效率。
例子：按年份分区的日志表

```sql
CREATE TABLE logs (
  id INT,
  log_date DATE,
  log_data TEXT
) PARTITION BY RANGE (YEAR(log_date)) (
  PARTITION p2021 VALUES LESS THAN (2022),
  PARTITION p2022 VALUES LESS THAN (2023),
  PARTITION p2023 VALUES LESS THAN (2024)
);
```

### 2-表分片

将一个大表的数据分散到**多个物理表**或**多个数据库**实例中的技术。与表分区不同，表分片是物理上的分割，而表分区是逻辑上的分割。
假设有一个用户表，可以按用户 ID 进行哈希分片，数据插入时，根据 ID 的哈希值决定插入哪个分片。

### 3. 哈希分片实现

##### 水平分片（按行分割数据），常用于数据量大的表

将表的数据分散到多个物理表中，每个表包含一部分数据。

```sql
-- 分片1
CREATE TABLE users_shard_1 (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  email VARCHAR(100)
);

-- 分片2
CREATE TABLE users_shard_2 (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  email VARCHAR(100)
);
```

分片使用：

```python
def get_shard_nubmer(user_id):
    return user_id % 2 + 1  # 简单的哈希函数，返回 1 或 2

# 插入数据
def insert_user(user_id, name, email):
    shard_number = get_shard_nubmer(user_id)
    query = f"INSERT INTO users_shard_{shard_number} (id, name, email) VALUES ({user_id}, '{name}', '{email}')"
    execute_query(query, (user_id, name, email))

# 查询数据
def get_user(user_id):
    shard_number = get_shard_nubmer(user_id)
    query = f"SELECT * FROM users_shard_{shard_number} WHERE id = {user_id}"
    return execute_query(query)

# 跨分片查询
def search_users_by_name(name):
    results = []
    for shard in [1, 2]:
        query = f"SELECT * FROM users_shard_{shard} WHERE name LIKE %s"
        results.extend(execute_query(query, (f"%{name}%",)))
    return results
```

##### 垂直分片（按列分割数据），

将表的列分割到多个物理表中，每个表包含一部分列。

```sql
CREATE TABLE users_basic (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  email VARCHAR(100)
);

CREATE TABLE users_detail (
  id INT PRIMARY KEY,
  age TINYINT NOT NULL UNSIGNED,
  address VARCHAR(255)
);
```

分片使用：

```python
# 插入数据
def insert_user(user_id, name, email, age, address):
    insert_basic_query = f"INSERT INTO users_basic (id, name, email) VALUES ({user_id}, '{name}', '{email}')"
    insert_detail_query = f"INSERT INTO users_detail (id, age, address) VALUES ({user_id}, {age}, '{address}')"
    execute_query(insert_basic_query, (user_id, name, email))
    execute_query(insert_detail_query, (user_id, age, address))

# 查询数据
def get_user(user_id):
    # 查询基本信息
    query1 = "SELECT * FROM users_basic WHERE id = %s"
    basic_info = execute_query(query1, (user_id,))

    # 查询详细信息
    query2 = "SELECT * FROM users_detail WHERE id = %s"
    detail_info = execute_query(query2, (user_id,))

    # 合并结果
    return {**basic_info[0], **detail_info[0]} if basic_info and detail_info else None

# 查询指定参数
def search_users_by_name(name):
    query = "SELECT * FROM users_basic WHERE name LIKE %s"
    return execute_query(query, (f"%{name}%",))

# 删除数据
def delete_user(user_id):
    # 删除基本信息
    query1 = "DELETE FROM users_basic WHERE id = %s"
    execute_query(query1, (user_id,))

    # 删除详细信息
    query2 = "DELETE FROM users_detail WHERE id = %s"
    execute_query(query2, (user_id,))

# 跨分片查询，与应用层进行合并数据不同，跨分片查询在数据库层合并数据，利用JOIN方法只需一次查询
def get_full_user_info(user_id):
    # b*选择users_basic表所有列，d.age, d.address选择users_detail表的age和address列，连接两个表，条件是id相等
    query = """
    SELECT b.*, d.age, d.address
    FROM users_basic b
    JOIN users_detail d ON b.id = d.id
    WHERE b.id = %s
    """
    return execute_query(query, (user_id,))
```

# 数据备份与恢复

### 定期备份重要数据

例子：每日备份users表

```sql
mysqldump -u username -p database_name users > users_backup.sql
```
