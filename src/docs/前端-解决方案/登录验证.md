# 短信验证码

### 安全性

1. 后端限制同一个用户、IP的请求频率，如60秒内不能再次发送
2. 使用图形验证码（多次验证失败后弹出）：后端返回图形验证码图片，并设置图形码的有效期

# 图形验证码

封装图形验证码 hook

```ts
import { ref, onMounted } from "vue";

/**
 * 绘制图形验证码
 * @param width - 图形宽度
 * @param height - 图形高度
 */
export const useImageVerify = (width = 120, height = 40) => {
  const domRef = ref<HTMLCanvasElement>();
  const imgCode = ref("");

  function setImgCode(code: string) {
    imgCode.value = code;
  }

  function getImgCode() {
    if (!domRef.value) return;
    imgCode.value = draw(domRef.value, width, height);
  }

  onMounted(() => {
    getImgCode();
  });

  return {
    domRef,
    imgCode,
    setImgCode,
    getImgCode
  };
};

function randomNum(min: number, max: number) {
  const num = Math.floor(Math.random() * (max - min) + min);
  return num;
}

function randomColor(min: number, max: number) {
  const r = randomNum(min, max);
  const g = randomNum(min, max);
  const b = randomNum(min, max);
  return `rgb(${r},${g},${b})`;
}

function draw(dom: HTMLCanvasElement, width: number, height: number) {
  let imgCode = "";

  const NUMBER_STRING = "0123456789";

  const ctx = dom.getContext("2d");
  if (!ctx) return imgCode;

  ctx.fillStyle = randomColor(180, 230);
  ctx.fillRect(0, 0, width, height);
  for (let i = 0; i < 4; i += 1) {
    const text = NUMBER_STRING[randomNum(0, NUMBER_STRING.length)];
    imgCode += text;
    const fontSize = randomNum(18, 41);
    const deg = randomNum(-30, 30);
    ctx.font = `${fontSize}px Simhei`;
    ctx.textBaseline = "top";
    ctx.fillStyle = randomColor(80, 150);
    ctx.save();
    ctx.translate(30 * i + 15, 15);
    ctx.rotate((deg * Math.PI) / 180);
    ctx.fillText(text, -15 + 5, -15);
    ctx.restore();
  }
  for (let i = 0; i < 5; i += 1) {
    ctx.beginPath();
    ctx.moveTo(randomNum(0, width), randomNum(0, height));
    ctx.lineTo(randomNum(0, width), randomNum(0, height));
    ctx.strokeStyle = randomColor(180, 230);
    ctx.closePath();
    ctx.stroke();
  }
  for (let i = 0; i < 41; i += 1) {
    ctx.beginPath();
    ctx.arc(randomNum(0, width), randomNum(0, height), 1, 0, 2 * Math.PI);
    ctx.closePath();
    ctx.fillStyle = randomColor(150, 200);
    ctx.fill();
  }
  return imgCode;
}
```

# 记住密码

- 记住的时长 1d、7d、30d 等
- 将登录 token 保存在 cookie 中，如果勾选了记住登录，根据记住时长设置 cookie 的过期时间

# 无感刷新 token

### access token 与 refresh token

- `access token`：**短生命周期** ，存储用户信息，每个请求携带
- `refresh token`：**长生命周期** ，随机字符串，不含用户信息，刷新`access token`时使用
- `refresh token`生命周期更长，其安全保护更加重要：
  1.  与用户IP绑定
  2.  与设备绑定
  3.  每次刷新token，旧的`refresh token`失效
  4.  检查`refresh token`被盗或滥用，将该token加入黑名单
- **为什么需要refresh token**？`access token`不够高，所以其周期短，如果加强其安全性，每次请求都要进行安全验证，影响请求速度。所以安全性高，生命周期长，不需要频繁使用的`refresh token`应运而生

### token刷新流程

1. 登录后，接口返回 `access token` + `refresh token` + `access token`过期时间
2. 每次请求判断 `access token` 是否过期
3. 如果已过期，用`refresh token`请求更新 token，同时`refresh token`失效，生成新的`refresh token`
4. 在请求过程中，设置更新标识，更新期间的其他请求先添加到请求队列
5. 更新成功后，再执行队列中的请求，并更新缓存中的 token
6. 退出登录、修改密码等时，后端需强制失效`refresh token`

##### 代码案例

```ts
/** 请求拦截 */
function httpInterceptorsRequest(): void {
  PureHttp.axiosInstance.interceptors.request.use(
    async (config: PureHttpRequestConfig): Promise<any> => {
      // 开启进度条动画
      NProgress.start();
      // 优先判断post/get等方法是否传入回调，否则执行初始化设置等回调
      if (typeof config.beforeRequestCallback === "function") {
        config.beforeRequestCallback(config);
        return config;
      }
      if (PureHttp.initConfig.beforeRequestCallback) {
        PureHttp.initConfig.beforeRequestCallback(config);
        return config;
      }
      /** 请求白名单，放置一些不需要`token`的接口（通过设置请求白名单，防止`token`过期后再请求造成的死循环问题） */
      const whiteList = ["/refresh-token", "/login"];
      return whiteList.some(url => config.url.endsWith(url))
        ? config
        : new Promise(resolve => {
            const data = getToken();
            if (data) {
              const now = new Date().getTime();
              const expired = parseInt(data.expires) - now <= 0;
              if (expired) {
                if (!PureHttp.isRefreshing) {
                  PureHttp.isRefreshing = true;
                  // token过期刷新
                  useUserStoreHook()
                    .handRefreshToken({ refreshToken: data.refreshToken })
                    .then(res => {
                      const token = res.data.accessToken;
                      config.headers["Authorization"] = formatToken(token);
                      PureHttp.requests.forEach(cb => cb(token));
                      PureHttp.requests = [];
                    })
                    .finally(() => {
                      PureHttp.isRefreshing = false;
                    });
                }
                resolve(PureHttp.retryOriginalRequest(config));
              } else {
                config.headers["Authorization"] = formatToken(data.accessToken);
                resolve(config);
              }
            } else {
              resolve(config);
            }
          });
    },
    error => {
      return Promise.reject(error);
    }
  );
}
```
